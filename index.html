<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Pierre's Pickleball Planner</title>
  <style>
    :root {
      --gap: 12px;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --body: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
      --ink: #0b1320; --muted: #6b7688; --line: #dfe3ea; --bg: #f7f8fb; --warn: #b00020; --ok: #135d13;
      --warn-bg: #fff3f3; --warn-border: #ffc7c7;
    }
    html, body { height: 100%; }
    body { font-family: var(--body); color: var(--ink); margin: 16px; }

    h1 { font-size: 20px; margin: 0 0 12px; }
    h2 { font-size: 14px; margin: 16px 0 6px; color: var(--muted); }

    .grid { display: grid; grid-template-columns: 1fr 1fr; gap: var(--gap); }
    .col { display: flex; flex-direction: column; gap: 8px; }
    label { font-size: 12px; color: var(--muted); }

    textarea, input[type="text"], input[type="number"], button {
      font: inherit; padding: 8px 10px; border: 1px solid var(--line); border-radius: 8px; background: white; color: inherit;
    }
    textarea { min-height: 120px; resize: vertical; }

    .row { display: flex; gap: var(--gap); align-items: center; flex-wrap: wrap; }

    .controls button { padding: 10px 14px; cursor: pointer; }
    button[disabled] { opacity: 0.5; cursor: not-allowed; }

    .warn {
      color: var(--warn);
      font-size: 14px; /* larger */
      background: var(--warn-bg);
      border: 2px solid var(--warn-border);
      border-left: 6px solid var(--warn);
      padding: 10px 12px;
      border-radius: 8px;
    }
    .muted { color: var(--muted); font-size: 12px; }

    .error { border-color: var(--warn); box-shadow: 0 0 0 2px rgba(176,0,32,0.1); }

    pre#output { font-family: var(--mono); white-space: pre; background: var(--bg); border: 1px solid var(--line); border-radius: 8px; padding: 12px; overflow: auto; }

    #summary { color: var(--muted); font-size: 14px; margin-top: 6px; }
    #summary .percent { font-weight: 700; font-size: 18px; }

    .hidden { display: none !important; }

    .out-controls { margin-top: 8px; display: flex; gap: 8px; align-items: center; flex-wrap: wrap; }
    .out-controls input[type="text"] { width: 180px; }

    /* Modal */
    .modal { position: fixed; inset: 0; background: rgba(0,0,0,0.35); display: none; align-items: center; justify-content: center; padding: 16px; }
    .modal.show { display: flex; }
    .dialog { background: #fff; border: 1px solid var(--line); border-radius: 12px; max-width: 820px; width: 100%; max-height: min(88vh, 1000px); box-shadow: 0 10px 30px rgba(0,0,0,0.12); display: flex; flex-direction: column; }
    .dialog header { padding: 14px 16px; border-bottom: 1px solid var(--line); font-weight: 700; flex: 0 0 auto; }
    .dialog .body { padding: 14px 16px; display: flex; flex-direction: column; gap: 10px; overflow: auto; flex: 1 1 auto; }
    .dialog footer { padding: 12px 16px; border-top: 1px solid var(--line); display: flex; gap: 8px; justify-content: flex-end; flex: 0 0 auto; }
    .form-row { display: grid; grid-template-columns: 1fr minmax(120px, 160px); gap: 10px; align-items: center; }
    .desc { color: var(--muted); font-size: 12px; margin-top: -4px; grid-column: 1 / -1; }
    .table { width: 100%; border-collapse: collapse; font-family: var(--mono); }
    .table th, .table td { text-align: left; padding: 6px 8px; border-bottom: 1px solid var(--line); }
    .table th { font-weight: 700; color: var(--muted); }
  </style>
</head>
<body>
  <h1>Pierre's Pickleball Planner</h1>

  <div class="grid">
    <div class="col">
      <h2>Players</h2>
      <label for="males">Male players (one per line or commas)</label>
      <textarea id="males" placeholder="Joe&#10;Frank&#10;Chris"></textarea>

      <label for="females">Female players (one per line or commas)</label>
      <textarea id="females" placeholder="Anna&#10;Liz&#10;Kim"></textarea>
    </div>

    <div class="col">
      <h2>Courts & Schedule</h2>
      <label for="courts">Court names (spaces, commas, or new lines)</label>
      <textarea id="courts" placeholder="1 2 4"></textarea>

      <div class="row">
        <div style="display:flex; flex-direction:column; gap:6px;">
          <label for="start">Start time</label>
          <input id="start" type="text" value="06:00 AM" />
        </div>
        <div style="display:flex; flex-direction:column; gap:6px;">
          <label for="slot">Slot length (min)</label>
          <input id="slot" type="number" min="5" max="120" value="15" />
        </div>
        <div style="display:flex; flex-direction:column; gap:6px;">
          <label for="cycles"># of cycles</label>
          <input id="cycles" type="number" min="1" max="30" value="8" />
        </div>
      </div>

      <div class="row controls" style="margin-top:8px;">
        <button id="generate">Generate</button>
        <button id="tryAgain" disabled>Try for better</button>
        <button id="setupBtn">Setup</button>
      </div>
    </div>
  </div>

  <div id="warnings" class="warn hidden" style="margin-top:10px;"></div>

  <h2>Output</h2>
  <pre id="output" aria-live="polite">(no schedule yet)</pre>
  <div id="summary"></div>
  <div class="out-controls">
    <label class="muted" for="printTitle">Title</label>
    <input id="printTitle" type="text" value="Sunrise Smashers" />
    <label class="muted" for="printSubtitle">Subtitle</label>
    <input id="printSubtitle" type="text" value="Schedule" />
    <button id="copyBtn" disabled>Copy</button>
    <button id="printBtn" disabled>Print</button>
    <button id="detailsBtn" disabled>Details</button>
  </div>

  <!-- Setup Modal -->
  <div id="setupModal" class="modal" role="dialog" aria-modal="true" aria-labelledby="setupTitle">
    <div class="dialog">
      <header id="setupTitle">Setup: Weights</header>
      <div class="body">
        <div class="muted">Adjust the weights that influence schedule scoring. Positive favors, negative penalizes.</div>
        <div id="weightsForm"></div>
      </div>
      <footer>
        <button id="setupReset">Reset to defaults</button>
        <div style="flex:1"></div>
        <button id="setupCancel">Cancel</button>
        <button id="setupSave">Save</button>
      </footer>
    </div>
  </div>

  <!-- Details Modal -->
  <div id="detailsModal" class="modal" role="dialog" aria-modal="true" aria-labelledby="detailsTitle">
    <div class="dialog">
      <header id="detailsTitle">Score Details</header>
      <div class="body">
        <div id="detailsTableWrap"></div>
        <div class="muted">Note: Totals exclude pairing heuristics (LOCAL) used inside a foursome.</div>
      </div>
      <footer>
        <div style="flex:1"></div>
        <button id="detailsClose">Close</button>
      </footer>
    </div>
  </div>

  <script>
  // ----------------------------
  // Config (tweakable in code)
  // ----------------------------
  const CONFIG = {
    ITERATIONS: 3000, // iterations per run; tune for performance
    WEIGHTS: {
      MIXED_FOURSOME: +12,
      THREE_ONE: -10,
      FOUR_ZERO: -6,
      SEGREGATED_TEAMS: -5,
      REPEAT_PARTNER: -14,
      REPEAT_OPPONENT: -4,
      BYE_EXCESS: -30,
      BYE_CONSECUTIVE: -6,
      // Normalized excess penalties (sum over players of amount above average)
      EXCESS_REPEAT_PARTNER: -3,
      EXCESS_REPEAT_OPPONENT: -2,
      EXCESS_THREE_ONE: -1.5,
      EXCESS_FOUR_ZERO: -1,
      // Proximity penalties (sum of inverse gaps between consecutive occurrences)
      PROX_REPEAT_PARTNER: -2,
      PROX_REPEAT_OPPONENT: -1,
      PROX_THREE_ONE: -0.75,
      PROX_FOUR_ZERO: -0.5,
    },
    LOCAL: { // heuristic for choosing pairings inside a foursome
      MIXED_PAIR: +3,
      MIXED_BOTH_PAIRS: +6,
      SEGREGATED_TEAMS: -8,
      REPEAT_PARTNER: -8,
      REPEAT_OPPONENT: -2,
    }
  };

  // Store a deep copy of defaults before any overrides
  const DEFAULT_WEIGHTS = JSON.parse(JSON.stringify(CONFIG.WEIGHTS));

  // ----------------------------
  // Utilities
  // ----------------------------
  const $ = (id) => document.getElementById(id);
  function setDisabled(el, val) { el.disabled = !!val; }
  function shuffle(arr) { // Fisher-Yates in-place
    for (let i = arr.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [arr[i], arr[j]] = [arr[j], arr[i]];
    }
    return arr;
  }
  function padRight(str, n) { str = String(str); return str + (" ".repeat(Math.max(0, n - str.length))); }

  // Cookie utilities
  function setCookie(name, value, days) {
    const d = new Date();
    d.setTime(d.getTime() + (days*24*60*60*1000));
    const expires = "; expires=" + d.toUTCString();
    document.cookie = name + "=" + encodeURIComponent(value) + expires + "; path=/";
  }
  function getCookie(name) {
    const nameEQ = name + "=";
    const ca = document.cookie.split(';');
    for (let i = 0; i < ca.length; i++) {
      let c = ca[i];
      while (c.charAt(0) === ' ') c = c.substring(1, c.length);
      if (c.indexOf(nameEQ) === 0) return decodeURIComponent(c.substring(nameEQ.length, c.length));
    }
    return null;
  }
  function loadWeightsFromCookie() {
    try {
      const raw = getCookie('PPP_WEIGHTS');
      if (!raw) return;
      const parsed = JSON.parse(raw);
      if (!parsed || typeof parsed !== 'object') return;
      for (const k of Object.keys(CONFIG.WEIGHTS)) {
        if (Object.prototype.hasOwnProperty.call(parsed, k)) {
          const v = Number(parsed[k]);
          if (Number.isFinite(v)) CONFIG.WEIGHTS[k] = v;
        }
      }
    } catch(e) { /* ignore */ }
  }
  function saveWeightsToCookie() {
    setCookie('PPP_WEIGHTS', JSON.stringify(CONFIG.WEIGHTS), 3650);
  }

  function normalizeName(s) {
    return s.trim().replace(/\s+/g, ' ');
  }
  function canonicalKey(s) {
    return normalizeName(s).toLowerCase();
  }

  function parseNames(text, gender) {
    if (!text) return [];
    const parts = text.replace(/,/g, '\n').split(/\n+/).map(t => normalizeName(t)).filter(Boolean);
    return parts.map(name => ({ id: canonicalKey(name), name, g: gender }));
  }
  function parseCourts(text) {
    if (!text) return [];
    const parts = text.replace(/[\n,]+/g, ' ').split(/\s+/).map(t => t.trim()).filter(Boolean);
    return parts; // treat as strings; keep order
  }

  function findDuplicates(items, keyFn = s => s) {
    const seen = new Map(); const dups = new Set();
    for (const it of items) {
      const k = keyFn(it);
      if (seen.has(k)) dups.add(k); else seen.set(k, true);
    }
    return Array.from(dups);
  }

  function parseStartTime(input) {
    // Accepts formats like "6:00 am", "06:00 AM", "6 AM" (optional :mm), with AM/PM
    const s = input.trim();
    const m = s.match(/^(\d{1,2})(?::(\d{2}))?\s*(AM|PM)$/i);
    if (!m) return null;
    let h = parseInt(m[1], 10);
    const min = m[2] ? parseInt(m[2], 10) : 0;
    const ampm = m[3].toUpperCase();
    if (h === 12) h = (ampm === 'AM') ? 0 : 12; else h = (ampm === 'PM') ? h + 12 : h;
    const d = new Date(); d.setHours(h, min, 0, 0);
    return d;
  }
  function formatAMPM(d) {
    let h = d.getHours(); const m = d.getMinutes();
    const am = h < 12; h = h % 12; if (h === 0) h = 12;
    const mm = String(m).padStart(2, '0');
    return `${h}:${mm} ${am ? 'AM' : 'PM'}`;
  }
  function buildTimes(startStr, minutes, cycles) {
    const start = parseStartTime(startStr);
    if (!start) return null;
    const out = [];
    for (let i = 0; i < cycles; i++) {
      const t = new Date(start.getTime() + i * minutes * 60 * 1000);
      out.push(formatAMPM(t));
    }
    return out;
  }

  // ----------------------------
  // Scheduling core
  // ----------------------------
  function generate(playersM, playersF, courts, times) {
    const P = playersM.length + playersF.length;
    const C = courts.length;
    if (P === 0 || C === 0) return { text: '', summary: 'No players or courts', score: -Infinity, matrix: null };

    const allPlayers = playersM.concat(playersF);
    const idToName = new Map(allPlayers.map(p => [p.id, p.name]));

    let best = null; let bestScore = -Infinity; let bestSummary = null; let bestMatrix = null; let bestCounts = null;

    for (let iter = 0; iter < CONFIG.ITERATIONS; iter++) {
      // Per-run history
      const hist = new Map(); // id -> { partners:Set, opponents:Set, byes:number, consec:number, lastBye:boolean, threeOne:number, fourZero:number }
      for (const p of allPlayers) hist.set(p.id, { partners: new Set(), opponents: new Set(), byes: 0, consec: 0, lastBye: false, threeOne: 0, fourZero: 0 });

      // Occurrence tracking for excess/proximity
      const repeatPartnerByPlayer = new Map(); // id -> count
      const repeatOpponentByPlayer = new Map(); // id -> count
      const threeOneByPlayer = new Map(); // id -> count
      const fourZeroByPlayer = new Map(); // id -> count
      const rpCycles = new Map(); // id -> array of cycle indices where repeat partner happened
      const roCycles = new Map(); // id -> array of cycle indices where repeat opponent happened
      const t1Cycles = new Map(); // id -> array of cycles where three-one occurred
      const f0Cycles = new Map(); // id -> array of cycles where four-zero occurred
      function addCount(map, id, ci) {
        map.set(id, (map.get(id) || 0) + 1);
      }
      function pushCycle(map, id, ci) {
        const arr = map.get(id) || [];
        arr.push(ci);
        map.set(id, arr);
      }

      const cyclesData = []; // [{ time, matches:[{court, a1,a2,b1,b2}], byes:[ids], active }]
      let totalScore = 0; let countMixed = 0; let countRepPartners = 0; let countRepOpps = 0;
      const runCounts = {
        MIXED_FOURSOME: 0,
        THREE_ONE: 0,
        FOUR_ZERO: 0,
        SEGREGATED_TEAMS: 0,
        REPEAT_PARTNER: 0,
        REPEAT_OPPONENT: 0,
        BYE_EXCESS: 0,
        BYE_CONSECUTIVE: 0,
      };

      for (let ci = 0; ci < times.length; ci++) {
        // Determine active courts & byes for this cycle
        const active = Math.min(C, Math.floor(P / 4));
        const byesNeeded = Math.max(0, P - (active * 4));

        const shuffled = shuffle(allPlayers.slice());
        const playing = shuffled.slice(0, active * 4);
        const byesList = shuffled.slice(active * 4, active * 4 + byesNeeded).map(p => p.id);

        // update bye consec tracking (but scoring applied at end)
        for (const p of allPlayers) {
          const h = hist.get(p.id);
          const isBye = byesList.includes(p.id);
          if (isBye) { if (h.lastBye) h.consec += 1; h.lastBye = true; h.byes += 1; }
          else { h.lastBye = false; }
        }

        // chunk playing into foursomes
        const foursomes = [];
        for (let i = 0; i < playing.length; i += 4) foursomes.push(playing.slice(i, i + 4));

        const matches = [];
        for (let fi = 0; fi < foursomes.length; fi++) {
          const four = foursomes[fi];
          const pairing = pairFoursome(four, hist);
          // Score composition & history effects now; update history
          const { score: localScore, mixed, repPartners, repOpps } = scoreMatch(pairing, hist);
          totalScore += localScore; // includes composition & repeats
          if (mixed) countMixed += 1;
          if (repPartners) countRepPartners += repPartners;
          if (repOpps) countRepOpps += repOpps;
          // Count criteria occurrences for WEIGHTS
          const all = [pairing.a[0], pairing.a[1], pairing.b[0], pairing.b[1]];
          const m = all.filter(p => p.g === 'M').length;
          const f = all.length - m;
          if (m === 2 && f === 2) {
            const aMixed = pairing.a[0].g !== pairing.a[1].g;
            const bMixed = pairing.b[0].g !== pairing.b[1].g;
            if (aMixed && bMixed) runCounts.MIXED_FOURSOME += 1; else runCounts.SEGREGATED_TEAMS += 1;
          } else if (m === 3 || f === 3) {
            runCounts.THREE_ONE += 1;
            for (const p of all) { addCount(threeOneByPlayer, p.id, ci); pushCycle(t1Cycles, p.id, ci); hist.get(p.id).threeOne += 1; }
          } else if (m === 4 || f === 4) {
            runCounts.FOUR_ZERO += 1;
            for (const p of all) { addCount(fourZeroByPlayer, p.id, ci); pushCycle(f0Cycles, p.id, ci); hist.get(p.id).fourZero += 1; }
          }
          if (repPartners) {
            runCounts.REPEAT_PARTNER += repPartners;
            const [a1,a2] = pairing.a, [b1,b2] = pairing.b;
            // For each pair with repeat, increment both players
            const ha1 = hist.get(a1.id), ha2 = hist.get(a2.id), hb1 = hist.get(b1.id), hb2 = hist.get(b2.id);
            if (ha1.partners.has(a2.id) || ha2.partners.has(a1.id)) { addCount(repeatPartnerByPlayer, a1.id, ci); addCount(repeatPartnerByPlayer, a2.id, ci); pushCycle(rpCycles, a1.id, ci); pushCycle(rpCycles, a2.id, ci); }
            if (hb1.partners.has(b2.id) || hb2.partners.has(b1.id)) { addCount(repeatPartnerByPlayer, b1.id, ci); addCount(repeatPartnerByPlayer, b2.id, ci); pushCycle(rpCycles, b1.id, ci); pushCycle(rpCycles, b2.id, ci); }
          }
          if (repOpps) {
            runCounts.REPEAT_OPPONENT += repOpps;
            const [a1,a2] = pairing.a, [b1,b2] = pairing.b;
            // If either player in a pair repeats any opponent, count both players of that pair once
            const ha1 = hist.get(a1.id), ha2 = hist.get(a2.id), hb1 = hist.get(b1.id), hb2 = hist.get(b2.id);
            const aRepeat = ha1.opponents.has(b1.id) || ha1.opponents.has(b2.id) || ha2.opponents.has(b1.id) || ha2.opponents.has(b2.id);
            const bRepeat = hb1.opponents.has(a1.id) || hb1.opponents.has(a2.id) || hb2.opponents.has(a1.id) || hb2.opponents.has(a2.id);
            if (aRepeat) { addCount(repeatOpponentByPlayer, a1.id, ci); addCount(repeatOpponentByPlayer, a2.id, ci); pushCycle(roCycles, a1.id, ci); pushCycle(roCycles, a2.id, ci); }
            if (bRepeat) { addCount(repeatOpponentByPlayer, b1.id, ci); addCount(repeatOpponentByPlayer, b2.id, ci); pushCycle(roCycles, b1.id, ci); pushCycle(roCycles, b2.id, ci); }
          }
          // Update history with this match
          commitMatchToHistory(pairing, hist);
          matches.push(pairing);
        }

        cyclesData.push({ time: times[ci], matches, byes: byesList, active });
      }

      // Fairness: byes distribution penalties (excess & consecutive)
      let actualTotalByes = 0; hist.forEach(h => actualTotalByes += h.byes);
      const avg = actualTotalByes / P;
      const bandLow = Math.floor(avg); const bandHigh = Math.ceil(avg);

      let excessPlayers = 0; let consecTotal = 0;
      hist.forEach(h => {
        if (h.byes > bandHigh) { const x = (h.byes - bandHigh); totalScore += CONFIG.WEIGHTS.BYE_EXCESS * x; runCounts.BYE_EXCESS += x; excessPlayers += 1; }
        if (h.consec > 0) { totalScore += CONFIG.WEIGHTS.BYE_CONSECUTIVE * h.consec; runCounts.BYE_CONSECUTIVE += h.consec; consecTotal += h.consec; }
      });

      // Post-run normalized excess and proximity penalties
      function average(map) {
        let sum = 0; let n = 0;
        map.forEach(v => { sum += v; n += 1; });
        return n ? (sum / n) : 0;
      }
      function sumExcess(map, avg) {
        let s = 0; map.forEach(v => { if (v > avg) s += (v - avg); }); return s;
      }
      function sumProximity(cycleMap) {
        // For each player, sort cycles and sum inverse gaps between consecutive occurrences: 1/(gap)
        let s = 0;
        cycleMap.forEach(arr => {
          const a = arr.slice().sort((x,y)=>x-y);
          for (let i = 1; i < a.length; i++) {
            const gap = a[i] - a[i-1];
            if (gap > 0) s += 1 / gap; // closer => larger penalty
          }
        });
        return s;
      }

      const avgRP = average(repeatPartnerByPlayer);
      const avgRO = average(repeatOpponentByPlayer);
      const avgT1 = average(threeOneByPlayer);
      const avgF0 = average(fourZeroByPlayer);

      const excessRP = sumExcess(repeatPartnerByPlayer, avgRP);
      const excessRO = sumExcess(repeatOpponentByPlayer, avgRO);
      const excessT1 = sumExcess(threeOneByPlayer, avgT1);
      const excessF0 = sumExcess(fourZeroByPlayer, avgF0);

      const proxRP = sumProximity(rpCycles);
      const proxRO = sumProximity(roCycles);
      const proxT1 = sumProximity(t1Cycles);
      const proxF0 = sumProximity(f0Cycles);

      const extraScore =
        CONFIG.WEIGHTS.EXCESS_REPEAT_PARTNER * excessRP +
        CONFIG.WEIGHTS.EXCESS_REPEAT_OPPONENT * excessRO +
        CONFIG.WEIGHTS.EXCESS_THREE_ONE * excessT1 +
        CONFIG.WEIGHTS.EXCESS_FOUR_ZERO * excessF0 +
        CONFIG.WEIGHTS.PROX_REPEAT_PARTNER * proxRP +
        CONFIG.WEIGHTS.PROX_REPEAT_OPPONENT * proxRO +
        CONFIG.WEIGHTS.PROX_THREE_ONE * proxT1 +
        CONFIG.WEIGHTS.PROX_FOUR_ZERO * proxF0;

      totalScore += extraScore;

      if (totalScore > bestScore) {
        bestScore = totalScore;
        best = cyclesData;
        bestSummary = { countMixed, countRepPartners, countRepOpps, actualTotalByes, avg, bandLow, bandHigh, excessPlayers, consecTotal, P };
        const includeResting = actualTotalByes > 0;
        bestMatrix = renderMatrix(best, courts, idToName, includeResting);
        bestCounts = {
          ...runCounts,
          EXCESS_REPEAT_PARTNER: excessRP,
          EXCESS_REPEAT_OPPONENT: excessRO,
          EXCESS_THREE_ONE: excessT1,
          EXCESS_FOUR_ZERO: excessF0,
          PROX_REPEAT_PARTNER: proxRP,
          PROX_REPEAT_OPPONENT: proxRO,
          PROX_THREE_ONE: proxT1,
          PROX_FOUR_ZERO: proxF0,
        };
      }
    }

    const text = renderBlocksTextFromMatrix(bestMatrix.header, bestMatrix.rows);

    // Percent score = average compliance across rules
    const totalMatches = best.reduce((acc, cyc) => acc + cyc.matches.length, 0);
    const mixedRate = totalMatches ? (bestSummary.countMixed / totalMatches) : 0;
    const partnerRate = totalMatches ? (1 - (bestSummary.countRepPartners / (2 * totalMatches))) : 1;
    const oppRate = totalMatches ? (1 - (bestSummary.countRepOpps / (4 * totalMatches))) : 1;
    let byeRate = 1;
    if (bestSummary.actualTotalByes > 0) {
      const overFrac = bestSummary.P ? (bestSummary.excessPlayers / bestSummary.P) : 0;
      const consecFrac = bestSummary.P ? Math.min(1, bestSummary.consecTotal / bestSummary.P) : 0;
      byeRate = 1 - 0.5 * (overFrac + consecFrac);
      if (byeRate < 0) byeRate = 0;
    }
    const pct = Math.round(100 * (mixedRate + partnerRate + oppRate + byeRate) / 4);

    const summary = `<span class="percent">Score: ${pct}%</span>  ·  Mixed games: ${bestSummary.countMixed}/${totalMatches}  ·  Repeat partners: ${bestSummary.countRepPartners}  ·  Repeat opponents: ${bestSummary.countRepOpps}`;
    return { text, summary, score: bestScore, percent: pct, matrix: bestMatrix, counts: bestCounts };
  }

  function pairFoursome(four, hist) {
    // four: [{id,name,g}, ...]
    const [p0, p1, p2, p3] = four;
    const opts = [
      { a:[p0,p1], b:[p2,p3] },
      { a:[p0,p2], b:[p1,p3] },
      { a:[p0,p3], b:[p1,p2] },
    ];
    let best = null; let bestScore = -Infinity;
    for (const opt of opts) {
      const s = scorePairingLocal(opt, hist);
      if (s > bestScore) { bestScore = s; best = opt; }
    }
    return best; // {a:[p,p], b:[p,p]}
  }

  function scorePairingLocal(pairing, hist) {
    const W = CONFIG.LOCAL;
    let s = 0;
    const [a1,a2] = pairing.a; const [b1,b2] = pairing.b;
    const aMixed = a1.g !== a2.g; const bMixed = b1.g !== b2.g;
    // prefer mixed pairs
    if (aMixed) s += W.MIXED_PAIR; if (bMixed) s += W.MIXED_PAIR;
    if (aMixed && bMixed) s += W.MIXED_BOTH_PAIRS;
    // discourage segregated MM vs FF (or FF vs MM)
    const aSame = a1.g === a2.g; const bSame = b1.g === b2.g;
    if (aSame && bSame && a1.g !== b1.g) s += W.SEGREGATED_TEAMS;
    // discourage repeat partners
    const ha1 = hist.get(a1.id), ha2 = hist.get(a2.id), hb1 = hist.get(b1.id), hb2 = hist.get(b2.id);
    if (ha1.partners.has(a2.id) || ha2.partners.has(a1.id)) s += W.REPEAT_PARTNER;
    if (hb1.partners.has(b2.id) || hb2.partners.has(b1.id)) s += W.REPEAT_PARTNER;
    // avoid repeat opponents
    const aOpps = [b1.id, b2.id], bOpps = [a1.id, a2.id];
    for (const id of aOpps) if (ha1.opponents.has(id) || ha2.opponents.has(id)) s += W.REPEAT_OPPONENT;
    for (const id of bOpps) if (hb1.opponents.has(id) || hb2.opponents.has(id)) s += W.REPEAT_OPPONENT;
    return s;
  }

  function scoreMatch(pairing, hist) {
    const W = CONFIG.WEIGHTS;
    const all = [pairing.a[0], pairing.a[1], pairing.b[0], pairing.b[1]];
    const m = all.filter(p => p.g === 'M').length;
    const f = all.length - m;

    let s = 0; let mixed = false; let repPartners = 0; let repOpps = 0;
    if (m === 2 && f === 2) {
      const aMixed = pairing.a[0].g !== pairing.a[1].g;
      const bMixed = pairing.b[0].g !== pairing.b[1].g;
      if (aMixed && bMixed) { s += W.MIXED_FOURSOME; mixed = true; }
      else { s += W.SEGREGATED_TEAMS; }
    } else if (m === 3 || f === 3) {
      s += W.THREE_ONE;
    } else if (m === 4 || f === 4) {
      s += W.FOUR_ZERO;
    }

    // Repeat partners / opponents penalties (relative to history before this match)
    const [a1,a2] = pairing.a, [b1,b2] = pairing.b;
    const ha1 = hist.get(a1.id), ha2 = hist.get(a2.id), hb1 = hist.get(b1.id), hb2 = hist.get(b2.id);
    const rptA = (ha1.partners.has(a2.id) || ha2.partners.has(a1.id));
    const rptB = (hb1.partners.has(b2.id) || hb2.partners.has(b1.id));
    if (rptA) { s += W.REPEAT_PARTNER; repPartners += 1; }
    if (rptB) { s += W.REPEAT_PARTNER; repPartners += 1; }

    const aOppIds = [b1.id, b2.id];
    const bOppIds = [a1.id, a2.id];
    // Count if any opponent repeats for each player (per player basis)
    for (const id of aOppIds) {
      const ha1 = hist.get(a1.id), ha2 = hist.get(a2.id);
      if (ha1.opponents.has(id)) { s += W.REPEAT_OPPONENT; repOpps += 1; break; }
    }
    for (const id of aOppIds) {
      const ha1 = hist.get(a1.id), ha2 = hist.get(a2.id);
      if (ha2.opponents.has(id)) { s += W.REPEAT_OPPONENT; repOpps += 1; break; }
    }
    for (const id of bOppIds) {
      const hb1 = hist.get(b1.id), hb2 = hist.get(b2.id);
      if (hb1.opponents.has(id)) { s += W.REPEAT_OPPONENT; repOpps += 1; break; }
    }
    for (const id of bOppIds) {
      const hb1 = hist.get(b1.id), hb2 = hist.get(b2.id);
      if (hb2.opponents.has(id)) { s += W.REPEAT_OPPONENT; repOpps += 1; break; }
    }

    return { score: s, mixed, repPartners, repOpps };
  }

  function commitMatchToHistory(pairing, hist) {
    const [a1,a2] = pairing.a, [b1,b2] = pairing.b;
    hist.get(a1.id).partners.add(a2.id); hist.get(a2.id).partners.add(a1.id);
    hist.get(b1.id).partners.add(b2.id); hist.get(b2.id).partners.add(b1.id);
    // Opponents
    for (const p of [a1,a2]) { hist.get(p.id).opponents.add(b1.id); hist.get(p.id).opponents.add(b2.id); }
    for (const p of [b1,b2]) { hist.get(p.id).opponents.add(a1.id); hist.get(p.id).opponents.add(a2.id); }
  }

  function renderMatrix(cyclesData, courts, idToName, includeResting) {
    // Build a matrix for textual table: header + rows (arrays of strings)
    const header = ["Time"].concat(courts.map(c => `Court ${c}`));
    if (includeResting) header.push("Resting");
    const rows = [];

    for (const cyc of cyclesData) {
      const row = [cyc.time];
      let active = cyc.active; let mi = 0;
      for (let ci = 0; ci < courts.length; ci++) {
        if (ci < active) {
          const m = cyc.matches[mi++];
          if (!m) { row.push('—'); continue; }
          const text = `${m.a[0].name} & ${m.a[1].name} vs ${m.b[0].name} & ${m.b[1].name}`;
          row.push(text);
        } else { row.push('—'); }
      }
      if (includeResting) {
        const restNames = (cyc.byes || []).map(id => idToName.get(id) || id).join(', ');
        row.push(restNames || '—');
      }
      rows.push(row);
    }
    return { header, rows };
  }

  function renderTextTable(header, rows) {
    // Column widths
    const cols = header.length;
    const widths = Array(cols).fill(0);
    for (let c = 0; c < cols; c++) widths[c] = Math.max(widths[c], header[c].length);
    for (const r of rows) for (let c = 0; c < cols; c++) widths[c] = Math.max(widths[c], (r[c] || '').length);
    const gap = '  ';

    const headerLine = header.map((h,i) => padRight(h, widths[i])).join(gap);
    const lines = [headerLine];
    for (const r of rows) lines.push(r.map((cell,i) => padRight(cell || '', widths[i])).join(gap));
    return lines.join('\n');
  }

  function renderBlocksTextFromMatrix(header, rows) {
    // header: ["Time", "Court X", ..., (optional) "Resting"]
    if (!header || !rows) return '';
    const hasResting = header[header.length - 1] === 'Resting';
    const lastCourtIdx = hasResting ? header.length - 2 : header.length - 1;
    const lines = [];
    for (const r of rows) {
      const time = r[0] || '';
      if (time) lines.push(`Time ${time}`);
      for (let i = 1; i <= lastCourtIdx - 0; i++) {
        const label = header[i];
        const val = r[i];
        if (val && val !== '—') {
          lines.push(`  ${label}: ${val}`);
        }
      }
      if (hasResting) {
        const rest = r[header.length - 1];
        if (rest && rest !== '—') {
          lines.push(`  Resting: ${rest}`);
        }
      }
      lines.push(''); // blank line between time blocks
    }
    return lines.join('\n');
  }

  // ----------------------------
  // UI glue
  // ----------------------------
  let lastBestScore = -Infinity; let lastText = ''; let lastMatrix = null; let lastCounts = null; let dirty = true;
  const WEIGHT_DESCRIPTIONS = {
    MIXED_FOURSOME: 'Mixed foursome: both pairs are mixed gender',
    THREE_ONE: '3 of one gender with 1 of the other in a foursome',
    FOUR_ZERO: 'All same gender in a foursome',
    SEGREGATED_TEAMS: 'Segregated teams: MM vs FF (or vice versa)',
    REPEAT_PARTNER: 'Same partners appear together again',
    REPEAT_OPPONENT: 'A player faces an opponent they have already played',
    BYE_EXCESS: 'Extra byes beyond the fair-share band',
    BYE_CONSECUTIVE: 'Consecutive byes for the same player',
    EXCESS_REPEAT_PARTNER: 'Excess repeats of partners above average (sum over players)',
    EXCESS_REPEAT_OPPONENT: 'Excess repeats of opponents above average (sum over players)',
    EXCESS_THREE_ONE: 'Excess 3–1 occurrences above average (sum over players)',
    EXCESS_FOUR_ZERO: 'Excess 4–0 occurrences above average (sum over players)',
    PROX_REPEAT_PARTNER: 'Proximity of partner repeats (closer repeats penalized more)',
    PROX_REPEAT_OPPONENT: 'Proximity of opponent repeats (closer repeats penalized more)',
    PROX_THREE_ONE: 'Proximity of 3–1 occurrences per player',
    PROX_FOUR_ZERO: 'Proximity of 4–0 occurrences per player',
  };

  function clearOutput(onChangeMsg = true) {
    $("output").textContent = onChangeMsg ? '(no schedule yet)' : '';
    $("summary").innerHTML = '';
    setDisabled($("copyBtn"), true);
    setDisabled($("printBtn"), true);
    setDisabled($("detailsBtn"), true);
    setDisabled($("tryAgain"), true);
    lastBestScore = -Infinity; lastText = ''; lastMatrix = null;
  }

  function collectAndValidate() {
    const males = parseNames($("males").value, 'M');
    const females = parseNames($("females").value, 'F');
    const courts = parseCourts($("courts").value);
    const slot = Math.max(1, parseInt($("slot").value || '15', 10));
    const cycles = Math.max(1, parseInt($("cycles").value || '8', 10));
    const startStr = $("start").value.trim();

    // Clear error styles
    $("males").classList.remove('error');
    $("females").classList.remove('error');
    $("courts").classList.remove('error');

    const warnings = [];

    // Duplicate players across combined list (case-insensitive)
    const all = males.concat(females);
    const dupKeys = findDuplicates(all, p => p.id);
    if (dupKeys.length) {
      const dupNames = new Set();
      for (const p of all) if (dupKeys.includes(p.id)) dupNames.add(p.name);
      warnings.push(`Duplicate player names detected (fix before generating): ${Array.from(dupNames).join(', ')}`);
      // Highlight both textareas
      $("males").classList.add('error');
      $("females").classList.add('error');
    }

    // Duplicate courts (warn but proceed)
    const courtDupKeys = findDuplicates(courts, s => s.toLowerCase());
    if (courtDupKeys.length) {
      const shown = courts.filter(c => courtDupKeys.includes(c.toLowerCase()));
      warnings.push(`Duplicate court names: ${Array.from(new Set(shown)).join(', ')}`);
      $("courts").classList.add('error');
    }

    // Validate counts
    const P = all.length; const C = courts.length; const S = 4 * C;
    if (P === 0) warnings.push('No players provided.');
    if (C === 0) warnings.push('No courts provided.');

    if (P - S > 3) warnings.push(`More than 3 resters per cycle (players: ${P}, seats: ${S}).`);
    if (S - P >= 4) warnings.push(`Unused courts likely (players: ${P}, seats: ${S}).`);

    const times = buildTimes(startStr, slot, cycles);
    if (!times) warnings.push('Invalid start time. Use format like "06:00 AM".');

    return { males, females, courts, times, warnings, hasBlocking: dupKeys.length > 0 || !times || P === 0 || C === 0 };
  }

  function showWarnings(warns) {
    const box = $("warnings");
    if (!warns.length) { box.textContent = ''; box.classList.add('hidden'); return; }
    box.classList.remove('hidden');
    box.innerHTML = warns.map(w => `• ${w}`).join('<br/>');
  }

  function runGenerate(replaceOnlyIfBetter = false) {
    const { males, females, courts, times, warnings, hasBlocking } = collectAndValidate();
    showWarnings(warnings);
    if (hasBlocking) { clearOutput(); return; }
    const { text, summary, score, matrix, counts } = generate(males, females, courts, times);
    if (!replaceOnlyIfBetter || score > lastBestScore) {
      lastBestScore = score; lastText = text; lastMatrix = matrix; lastCounts = counts; dirty = false;
      $("output").textContent = text;
      $("summary").innerHTML = summary;
      setDisabled($("copyBtn"), !text.trim());
      setDisabled($("printBtn"), !text.trim());
      setDisabled($("detailsBtn"), !text.trim());
      setDisabled($("tryAgain"), false);
    }
  }

  function copyOutput() {
    const txt = $("output").textContent || '';
    if (!txt.trim()) return;
    if (navigator.clipboard && navigator.clipboard.writeText) {
      navigator.clipboard.writeText(txt);
    } else {
      const ta = document.createElement('textarea');
      ta.value = txt; document.body.appendChild(ta); ta.select();
      try { document.execCommand('copy'); } catch(e) {}
      document.body.removeChild(ta);
    }
  }

  function buildPrintBlocksHTML(matrix) {
    if (!matrix) return '';
    const esc = (s) => String(s).replace(/[&<>]/g, ch => ({'&':'&amp;','<':'&lt;','>':'&gt;'}[ch]));
    const header = matrix.header;
    const hasResting = header[header.length - 1] === 'Resting';
    const lastCourtIdx = hasResting ? header.length - 2 : header.length - 1;
    const blocks = [];
    for (const r of matrix.rows) {
      const time = esc(r[0] || '');
      const lines = [];
      for (let i = 1; i <= lastCourtIdx - 0; i++) {
        const label = esc(header[i]);
        const val = r[i];
        if (val && val !== '—') {
          lines.push(`<div class=\"entry\"><span class=\"label\">${label}:</span> ${esc(val)}</div>`);
        }
      }
      if (hasResting) {
        const rest = r[header.length - 1];
        if (rest && rest !== '—') {
          lines.push(`<div class=\"entry resting\"><span class=\"label\">Resting:</span> ${esc(rest)}</div>`);
        }
      }
      blocks.push(`<div class=\"time-block\"><div class=\"time\">Time ${time}</div>${lines.join('')}</div>`);
    }
    return `<div class=\"blocks\">${blocks.join('')}</div>`;
  }

  function openPrintView() {
    const txt = $("output").textContent || '';
    if (!txt.trim() || !lastMatrix) return;
    const title = $("printTitle").value.trim() || 'Sunrise Smashers';
    const subtitle = $("printSubtitle").value.trim();
    const w = window.open('', '_blank');
    const blocksHTML = buildPrintBlocksHTML(lastMatrix);
    const css = `body{margin:24px;font-family:${CSS.escape(getComputedStyle(document.body).fontFamily)};color:#0b1320}
      h1{font-size:22px;margin:0 0 4px} h2{font-size:14px;margin:0 0 12px;color:#5b6678}
      .blocks{display:block}
      .time-block{margin:0 0 14px}
      .time-block .time{font-size:18px;font-weight:700;margin:0 0 6px}
      .entry{margin-left:12px;font-size:16px;line-height:1.35}
      .entry .label{font-weight:600}
      .entry.resting{color:#5b6678}
      @page{margin:15mm}`;
    const html = `<!doctype html><html><head><meta charset=\"utf-8\"><title>Schedule</title>
      <style>${css}</style>
      </head><body>
      <h1>${title.replace(/[&<>]/g, s => ({'&':'&amp;','<':'&lt;','>':'&gt;'}[s]))}</h1>
      ${subtitle ? `<h2>${subtitle.replace(/[&<>]/g, s => ({'&':'&amp;','<':'&lt;','>':'&gt;'}[s]))}</h2>` : ''}
      ${blocksHTML}
      <script>window.onload = () => { window.print(); }${'</scr' + 'ipt>'}${'</bo' + 'dy>'}${'</ht' + 'ml>'}$`;
    w.document.open(); w.document.write(html); w.document.close();
  }

  // Setup modal logic
  function openSetup() {
    renderWeightsForm(CONFIG.WEIGHTS);
    $("setupModal").classList.add('show');
  }
  function closeSetup() { $("setupModal").classList.remove('show'); }
  function renderWeightsForm(weights) {
    const wrap = $("weightsForm");
    const keys = Object.keys(weights);
    const rows = keys.map(k => {
      const desc = WEIGHT_DESCRIPTIONS[k] || '';
      return `<div class="form-row"><label for="w_${k}"><strong>${k}</strong></label><input id="w_${k}" type="number" step="any" value="${String(weights[k])}"></div>` + (desc ? `<div class="desc">${desc}</div>` : '');
    });
    wrap.innerHTML = rows.join('');
  }
  function readWeightsFromForm() {
    const out = { ...CONFIG.WEIGHTS };
    for (const k of Object.keys(CONFIG.WEIGHTS)) {
      const el = $("w_" + k);
      if (!el) continue;
      const v = Number(el.value);
      if (Number.isFinite(v)) out[k] = v;
    }
    return out;
  }
  function applyWeights(newWeights) {
    for (const k of Object.keys(CONFIG.WEIGHTS)) CONFIG.WEIGHTS[k] = Number(newWeights[k]);
    saveWeightsToCookie();
    markDirty();
  }
  function resetWeightsToDefaults() {
    renderWeightsForm(DEFAULT_WEIGHTS);
  }

  // Details modal logic
  function openDetails() {
    if (!lastCounts || !lastMatrix) return;
    const fmt = (n) => (Number.isInteger(n) ? String(n) : (Math.round(n * 10) / 10).toFixed(1));
    const rows = Object.keys(CONFIG.WEIGHTS).map(k => {
      const count = Number(lastCounts[k] || 0);
      const w = Number(CONFIG.WEIGHTS[k] || 0);
      const contrib = count * w;
      const desc = WEIGHT_DESCRIPTIONS[k] || '';
      return `<tr><td><strong>${k}</strong><div class="desc">${desc}</div></td><td>${fmt(count)}</td><td>${fmt(w)}</td><td>${fmt(contrib)}</td></tr>`;
    });
    const total = Object.keys(CONFIG.WEIGHTS).reduce((acc,k)=>acc + (Number(lastCounts[k]||0) * Number(CONFIG.WEIGHTS[k]||0)), 0);
    const html = `<table class="table"><thead><tr><th>Criterion</th><th>Count</th><th>Weight</th><th>Contribution</th></tr></thead><tbody>${rows.join('')}</tbody><tfoot><tr><th colspan=\"3\">Total (WEIGHTS only)</th><th>${fmt(total)}</th></tr></tfoot></table>`;
    $("detailsTableWrap").innerHTML = html;
    $("detailsModal").classList.add('show');
  }
  function closeDetails() { $("detailsModal").classList.remove('show'); }

  function markDirty() {
    dirty = true; clearOutput();
  }

  // Hook up events
  $("generate").addEventListener('click', () => { runGenerate(false); });
  $("tryAgain").addEventListener('click', () => { if (!dirty) runGenerate(true); });
  $("copyBtn").addEventListener('click', copyOutput);
  $("printBtn").addEventListener('click', openPrintView);
  $("setupBtn").addEventListener('click', openSetup);
  $("setupCancel").addEventListener('click', closeSetup);
  $("setupSave").addEventListener('click', () => { const nw = readWeightsFromForm(); applyWeights(nw); closeSetup(); });
  $("setupReset").addEventListener('click', resetWeightsToDefaults);
  $("detailsBtn").addEventListener('click', openDetails);
  $("detailsClose").addEventListener('click', closeDetails);

  // Any input change clears output and disables follow-up actions
  ["males","females","courts","start","slot","cycles","printTitle","printSubtitle"].forEach(id => {
    $(id).addEventListener('input', markDirty);
  });

  // Load saved weights from cookie, if any
  loadWeightsFromCookie();

  // Seed example for quick testing
  $("males").value = "Joe, Frank, Chris, Kevin, John, Matt, Chris S., Mark";
  $("females").value = "Anna, Liz, Kim, Sara";
  $("courts").value = "1 2 4";
  clearOutput();

  </script>
</body>
</html>
